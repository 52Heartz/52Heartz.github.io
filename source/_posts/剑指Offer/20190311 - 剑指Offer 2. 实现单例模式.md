---
title: 剑指Offer 2. 实现单例模式
mathjax: true
date: 2019-03-11 20:45:13
updated:
categories:
tags:
urlname: jian-zhi-offer-2
---

单例模式及其应用。

<!-- more -->

# 测试方法

## 说明

主要对线程安全进行测试，使用 `getInstance()` 方法获取实例，然后对实例调用 `hashCode()` 方法获取 `hashCode`，通过 `hashCode` 即可知道获取的是不是同一个实例，从而知道是不是线程安全的。

## 代码

```java
public class Singleton{
    //...

    public static void main(String[] args) {
        Thread[] threads = new Thread[10];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new TestThread();
        }

        for (Thread thread : threads) {
            thread.start();
        }
    }
}

class TestThread extends Thread {
    @Override
    public void run() {
        int counter = 2;
        while(counter-- >0){
            int hash = Singleton.getInstance().hashCode();
            System.out.printf("%s %d\n", this.getName(), hash);
        }
    }
}
```



# 写法1：懒汉式

```java
public class Singleton{
    private static Singleton instance;
    private Singleton(){}

    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }

        return instance;
    }
}
```

这种写法不是线程安全的，只能在单线程中使用。当有多个线程并发调用 `getInstance()` 方法的时候，有可能同时执行到 `if(instance == null)` 语句，所以可能创建多个实例。

## 测试

有可能需要重复运行很多次才会出现线程不安全的情况。

```java
public class Singleton{
    private static Singleton instance;
    private Singleton(){}

    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }

        return instance;
    }

    public static void main(String[] args) {
        Thread[] threads = new Thread[10];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new TestThread();
        }

        for (Thread thread : threads) {
            thread.start();
        }
    }
}

class TestThread extends Thread {
    @Override
    public void run() {
        int counter = 2;
        while(counter-- >0){
            int hash = Singleton.getInstance().hashCode();
            System.out.printf("%s %d\n", this.getName(), hash);
        }
    }
}
```

### 测试结果

```
Thread-1 323112275
Thread-1 709937305
Thread-9 709937305
Thread-9 709937305
Thread-8 709937305
Thread-8 709937305
Thread-6 709937305
Thread-6 709937305
Thread-7 709937305
Thread-7 709937305
Thread-5 709937305
Thread-4 709937305
Thread-4 709937305
Thread-3 709937305
Thread-0 709937305
Thread-0 709937305
Thread-2 323112275
Thread-3 709937305
Thread-5 709937305
Thread-2 709937305
```

### 解释说明

从输出结果可以看出来，有两次调用获取到的实例和其他几次的调用获取到的实例是不一样的。说明这种写法不是线程安全的。

还需要注意的是，调用 `getInstance()` 的顺序和输出的顺序并不是一致的。所以 `hashCOde` 相同的调用并不是连续输出的。



# 写法2：懒汉式改进

```java
public class Singleton{
    private Singleton(){}
    private static Singleton instance;

    public static synchronized Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }

        return instance;
    }
}
```

加上了 `synchronized` 关键字，现在可以做到线程安全，但是并不够高效。



# 写法3：饿汉式，`public static final` 成员变量

```java
public class Singleton{
    public static final Singleton INSTANCE = new Singleton();
    private Singleton(){}
    
    //...
}
```





# 写法4：饿汉式，工厂方法

```java
public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton(){}

    public static synchronized Singleton getInstance(){
        return instance;
    }
}
```

这种写法是线程安全的，因为类的实例在类加载的时候就被初始化的。类的初始化是通过 `ClassLoader` 类的 `loadClass()` 方法加载的，而 `loadClass()` 方法是由 `synchronized` 修饰的。







# 写法4：静态内部类

```java
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    private Singleton (){}
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;
    }  
}
```

这种写法也是线程安全的，和饿汉式的原因相同，因为类的实例在类加载的时候就被初始化的。类的初始化是通过 `ClassLoader` 类的 `loadClass()` 方法加载的，而 `loadClass()` 方法是由 `synchronized` 修饰的。



# 使用枚举

```java
public enum EasySingleton{
    INSTANCE;
}
```



# 单例模式的应用





# 参考资料

1. [如何正确地写出单例模式 - Jark's blog](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)
2. [Java Singletons Using Enum](https://dzone.com/articles/java-singletons-using-enum)
3. [5种JAVA单例模式的实现、原理和演化](<https://jooop.github.io/2017/04/07/5%E7%A7%8DJAVA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E6%BC%94%E5%8C%96/>)
4. [面试官：不使用synchronized和lock，如何实现一个线程安全的单例？](https://mp.weixin.qq.com/s/nt31pbECsQvf3NY-MT2_Ng)