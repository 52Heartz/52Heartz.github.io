---
title: Java面试基础
mathjax: true
date: 2019-03-02 15:48:14
updated:
categories:
- Java
tags:
urlname: java-interview-baiscs
---

# 基本概念

## Java对象的初始化顺序

1. 父类的静态变量
2. 子类的静态变量
3. 父类的实例变量
4. 父类的构造函数
5. 子类的实例变量
6. 子类的构造函数

<!-- more -->

## Java和C++的区别

- Java 是**纯粹的面向对象语言**，所有的对象都继承自 java.lang.Object，**C++ 为了兼容 C 即支持面向对象也支持面向过程**。
- Java 通过虚拟机从而实现**跨平台特性**，但是 C++ 依赖于**特定的平台**。
- Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
- Java 支持**自动垃圾回收**，而 C++ 需要**手动回收**。（C++11 中引入智能指针，使用引用计数法垃圾回收）
- **Java 不支持多重继承**，只能通过实现多个接口来达到相同目的，而 **C++ 支持多重继承**。
- Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
- Java 内置了线程的支持，而 C++ 需要依靠第三方库。
- Java 的 **goto 是保留字**，但是不可用，C++ 可以使用 goto。
- Java **不支持条件编译**，C++ 通过 #ifdef #ifndef 等预处理命令从而实现**条件编译**。

## 反射



[Java反射与注解 - 掘金](https://juejin.im/post/5b6ada37f265da0faf71f197)

[深入解析Java反射（1） - 基础](https://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F)



## 重载和重写

### 重写（Override）

重写发生在父类和子类之间，子类覆盖父类的同名方法叫做重写。重写必须保证返回值和形参不能改变。

- 参数列表必须完全与被重写方法的相同；
- 返回类型必须完全与被重写方法的返回类型相同；
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
- 父类的成员方法只能被它的子类重写。
- 声明为final的方法不能被重写。
- 声明为static的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个方法，则不能重写这个方法。

### 重载（Overload）

重载是对于同一个类来说，可以有多个同名但是功能不同的方法。

**重载规则:**

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

[Java 重写(Override)与重载(Overload)](http://www.runoob.com/java/java-override-overload.html)

### 静态内部类

静态内部类不能访问外围类的非静态数据。

普通内部类可以直接访问外围类的数据，包括私有数据。



## 序列化

transient关键字修饰的变量不能被序列化。



## 抽象类

抽象方法有函数名、形式参数，但是没有花括号 `{}`。



## HashCode() 和 equals() 方法

hashCode() 返回散列值，而 equals() 是用来判断两个对象是否完全等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。

1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。

2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。

