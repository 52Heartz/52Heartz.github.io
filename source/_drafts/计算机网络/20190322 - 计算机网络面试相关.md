---
title: 计算机网络面试相关
mathjax: true
date: 2019-03-22 19:47:20
updated:
categories:
tags:
urlname: about-computer-network-interview
---

计算机网络。

<!-- more -->



# 计算机网络的体系结构

TCP/IP 的四层模型，从上往下：

| 应用层     |
| ---------- |
| 运输层     |
| 网际层     |
| 网络接口层 |

OSI 的七层模型：

| 应用层     |
| ---------- |
| 表示层     |
| 会话层     |
| 运输层     |
| 网络层     |
| 数据链路层 |
| 物理层     |



# TCP 和 UDP 的区别

1. UDP 是无连接的，即发送数据之前不需要建立连接。
2. UDP 使用在尽最大努力交付，即不保证可靠交付，同时也不适用拥塞控制。
3. UDP 是面向报文的。UDP没有拥塞控制，很适合多媒体通信的要求。
4. UDP 支持一对一、一对多、多对一和多对多的交互通信。 
5. UDP 的首部开销小，只有 8 个字节。



1. TCP 是面向连接的传输层协议。
2. 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是一对一的。
3. TCP 提供可靠交付的服务。
4. TCP 提供全双工通信。
5. TCP 是面向字节流。
6. TCP 的首部最低 20 字节。



# 三次握手

三次握手只是一个比喻，主机 A 向主机 B 发送一次连接请求，就看做一次握手，那么双方合在一起要发送三次请求才能建立 TCP 连接，所以叫三次握手。

三次握手过程中涉及到字段：

| 字段名（区分大小写） | 字段说明                                                     |
| -------------------- | ------------------------------------------------------------ |
| SYN                  | 同步序号，为1表示连接请求，用于建立连接和使顺序号同步。      |
| seq                  | 发送方向接收方发送的数据字节数的计数标志。                   |
| ACK                  | 为1表示确认字段有效，为0表示报文中不包含确认字段，即忽略ack字段。 |
| ack                  | 确认号，只有ACK为1时，该字段才有效，回复的时候要ack=seq+1。  |

## 三次握手的原因

第三次握手是为了防止已经失效的连接请求到达服务器，让服务器错误建立连接。

就是客户端发到服务端的连接请求可能会在网络中滞留，那么很长时间都没有到达服务端，这个时候客户端会启动超时重传，会再次发出连接请求。如果没有三次握手，那么服务端就会对同一次请求建立两个连接，如果有三次握手，那么，客户端就会忽略服务器之后发送的对滞留连接的连接确认。



# 四次挥手

四次挥手过程中涉及到字段：

| 字段名（区分大小写） | 字段说明                                                     |
| -------------------- | ------------------------------------------------------------ |
| FIN                  | 用于释放连接，为1表示发送方已经没有数据发送了，即关闭本方数据流。 |
| seq                  | 发送方向接收方发送的数据字节数的计数标志。                   |
| ACK                  | 为1表示确认字段有效，为0表示报文中不包含确认字段，即忽略ack字段。 |
| ack                  | 确认号，只有ACK为1时，该字段才有效，回复的时候要ack=seq+1。  |

四次挥手的通俗解释：

（1）A 对 B 说：我要和你说再见了

（2）B 对 A 说：我听到了

（3）B 对 A 说：我也要说再见了

（4）A 对 B 说：我听到了



### 四次挥手的原因

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT

客户端收到服务端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL（Maximum Segment Lifetime）,也就是两倍的最大报文存活时间。这么做有两个理由：

（1）主要是防止服务器没有收到客户端发送的第四次挥手的报文，那么服务器超时没有收到第四次挥手的报文，会再次发送第三次挥手的报文，等待 2MSL 就是，如果服务端再次发送了第三次挥手的报文，客户端收到之后还可以再次发送第四次挥手的报文。

（2）另外也是为了让本连接持续时间内的所有报文都从网络中消失，使再建立的新的连接不会受到就的连接报文的影响。

在 TIME_WAIT 状态时两端的端口不能使用，要等到 2MSL 时间结束才可以继续使用。



# HTTP 状态码

| 状态码 | 原因短语             |
| ------ | -------------------- |
| 200    | OK                   |
| 301    | 永久移动             |
| 302    | 临时移动             |
| 400    | Bad Request 错误请求 |
| 404    | 未找到               |
| 500    | 内部服务器错误       |
| 502    | Bad Gateway 网关错误 |



# HTTP 和 HTTPS 的区别

1. http 是 HTTP 协议运行在 TCP 之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
2. https是 HTTP运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。
3. http 是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。
4. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。



# GET 和 POST 的区别

1. GET 被强制服务器支持
2. 浏览器对 URL 的长度有限制，所以 GET 请求不能代替 POST 发送大量数据。
3. GET 请求发送数据更小
4. GET请求是不安全的
5. POST 请求不能被缓存
6. POST 请求相对于 GET 请求是安全的。

